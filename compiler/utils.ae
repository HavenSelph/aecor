use "lib/math.ae"
use "compiler/tokens.ae"

def strsep(s: &string, delim: string): string extern

def edit_distance(str1: string, str2: string): i32 {
    let n = str1.len()
    let m = str2.len()
    let stride = m + 1

    // The stack _should_ be large enough to hold the entire matrix.
    let d: [[i32; m + 1]; n + 1]

    for let i = 0; i <= n; i += 1 {
        d[i][0] = i
    }
    for let j = 0; j <= m; j += 1 {
        d[0][j] = j
    }
    for let i = 1; i <= n; i += 1 {
        for let j = 1; j <= m; j += 1 {
            let x = d[i - 1][j] + 1
            let y = d[i][j - 1] + 1
            let z: i32
            if str1[i - 1] == str2[j - 1] {
                z = d[i - 1][j - 1]
            } else {
                z = d[i - 1][j - 1] + 1
            }
            d[i][j] = min(x, min(y, z))
        }
    }
    let result = d[n][m]
    return result
}

def find_word_suggestion(s: string, options: &Vector): string {
    let threshold = 5 // edit distance threshold

    if options.size == 0 return null

    let closest = options.at(0) as string
    let closest_distance = edit_distance(s, closest)

    for let i = 1; i < options.size; i += 1 {
        let option = options.at(i) as string
        let distance = edit_distance(s, option)
        if distance < closest_distance {
            closest = option
            closest_distance = distance
        }
    }
    if closest_distance > threshold return null
    return closest
}

////////////////////////////////////////////////////////////////////////////////

enum MessageType {
    Error
    Warning
    Note
}

def MessageType::to_color(this): string {
    return match this {
        Error => "\x1b[31m"
        Warning => "\x1b[33m"
        Note => "\x1b[32m"
    }
}

def MessageType::str(this): string {
    return match this {
        Error => "Error"
        Warning => "Warning"
        Note => "Note"
    }
}

def display_line() {
    println("--------------------------------------------------------------------------------")
}

def display_message(type: MessageType, span: Span, msg: string) {
    display_line()
    println("%s: %s: %s", span.start.str(), type.str(), msg)
    display_line()
}

def display_message_with_span(type: MessageType, span: Span, msg: string) {
    let color = MessageType::to_color(type)
    let reset = "\x1b[0m"

    let filename = span.start.filename;
    let file = File::open(filename, "r")
    defer file.close()

    let contents = file.slurp()
    defer free(contents)

    let around_offset = 1
    let min_line = max(span.start.line - around_offset, 1)
    let max_line = span.end.line + around_offset

    display_message(type, span, msg)
    let lines = contents
    let cur = strsep(&lines, "\n")
    let line_no = 1
    while cur? and line_no <= max_line {
        if line_no >= min_line and line_no <= max_line {
            print("%4d | ", line_no)
            if line_no == span.start.line {
                let start_col = span.start.col - 1
                let end_col = span.end.col - 1
                if span.end.line != span.start.line {
                    end_col = cur.len()
                }
                for let i = 0; i < start_col; i += 1 {
                    print("%c", cur[i])
                }
                print("%s", color)
                for let i = start_col; i < end_col; i += 1 {
                    print("%c", cur[i])
                }
                println("%s%s", reset, cur + end_col)
                println("%*s%s^ %s%s", start_col + 7, "", color, msg, reset)
            } else {
                println("%s", cur)
            }
        }
        line_no += 1
        cur = strsep(&lines, "\n")
    }
}

def error_loc(loc: Location, msg: string) exits {
    error_span(Span::make(loc, loc), msg)
}

// Just shows the line with the error
def error_span(span: Span, msg: string) exits {
    display_message_with_span(MessageType::Error, span, msg)
    display_line()
    exit(1)
}

// Shows the line with the error and an additional note
def error_span_note(span: Span, msg: string, note: string) exits {
    display_message_with_span(MessageType::Error, span, msg)
    display_message(MessageType::Note, span, note)
    exit(1)
}

// Shows the line with the error and an additional note at a different location
def error_span_note_span(msg_span: Span, msg: string, note_span: Span, note: string) exits {
    display_message_with_span(MessageType::Error, msg_span, msg)
    display_message_with_span(MessageType::Note, note_span, note)
    display_line()
    exit(1)
}

