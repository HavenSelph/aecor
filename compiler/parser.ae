use "./compiler/ast.ae"
use "./compiler/utils.ae"

struct Parser {
    tokens: &Vector
    curr: i32
}

def Parser::make(tokens: &Vector): &Parser {
    let parser = calloc(1, sizeof(Parser)) as &Parser
    parser.tokens = tokens
    parser.curr = 0
    return parser
}

def Parser::error(&this, msg: string) {
    error_span(.token().span, msg)
}

def Parser::unhandled_type(&this, func: string) {
    .error(`Unexpected token in {func}: {.token().type.str()}`)
}

def Parser::token(&this): &Token {
    return .tokens.at(.curr) as &Token
}

def Parser::token_is(&this, type: TokenType): bool {
    return .token().type == type
}

def Parser::consume_if(&this, type: TokenType): bool {
    if .token_is(type) {
        .curr += 1
        return true
    }
    return false
}

def Parser::consume_newline_or(&this, type: TokenType) {
    if .token_is(type) {
        .curr += 1
    } else if not .token().seen_newline {
        .error(`Expected {type.str()} or newline`)
    }
}

def Parser::consume(&this, type: TokenType): &Token {
    if not .consume_if(type) {
        .error(`Expected TokenType::{type.str()}`)
    }
    return .tokens.at(.curr - 1) as &Token
}


def Parser::parse_type(&this): &Type {
    let type = 0 as &Type
    let start_span = .token().span

    let running = true
    while running {
        if .token_is(TokenType::Ampersand) {
            type = Type::new_link(BaseType::Pointer, type, .token().span)
            .curr += 1
        } else {
            running = false
        }
    }

    if .token_is(TokenType::I32) {
        type = Type::new_link(BaseType::I32, type, start_span.join(.token().span))
        .curr += 1
    } else if .token_is(TokenType::Bool) {
        type = Type::new_link(BaseType::Bool, type, start_span.join(.token().span))
        .curr += 1
    } else if .token_is(TokenType::Char) {
        type = Type::new_link(BaseType::Char, type, start_span.join(.token().span))
        .curr += 1
    } else if .token_is(TokenType::U8) {
        type = Type::new_link(BaseType::U8, type, start_span.join(.token().span))
        .curr += 1
    } else if .token_is(TokenType::F32) {
        type = Type::new_link(BaseType::F32, type, start_span.join(.token().span))
        .curr += 1
    } else if .token_is(TokenType::String) {
        let span = start_span.join(.token().span)
        type = Type::new_link(BaseType::Char,
                              Type::new_link(BaseType::Pointer, type, span),
                              span)
        .curr += 1
    } else if .token_is(TokenType::UntypedPtr) {
        let span = start_span.join(.token().span)
        type = Type::new_link(BaseType::Void,
                              Type::new_link(BaseType::Pointer, type, span),
                              span)
        .curr += 1
    } else if .token_is(TokenType::Identifier) {
        type = Type::new_link(BaseType::Structure, type, start_span.join(.token().span))
        type.name = .consume(TokenType::Identifier).text
    } else {
        .unhandled_type("parse_type")
    }

    return type.reverse()
}

def Parser::parse_factor(&this, in_parens: bool): &AST {
    let node = 0 as &AST
    if .token_is(TokenType::IntLiteral) {
        node = AST::new(ASTType::IntLiteral, .token().span)
        let tok = .consume(TokenType::IntLiteral)
        node.u.num_literal = tok.text

    } else if .token_is(TokenType::FloatLiteral) {
        node = AST::new(ASTType::FloatLiteral, .token().span)
        let tok = .consume(TokenType::FloatLiteral)
        node.u.num_literal = tok.text

    } else if .token_is(TokenType::StringLiteral) {
        node = AST::new(ASTType::StringLiteral, .token().span)
        let tok = .consume(TokenType::StringLiteral)
        node.u.string_literal = tok.text

    } else if .token_is(TokenType::True) or .token_is(TokenType::False) {
        let tok = .consume(.token().type)
        node = AST::new(ASTType::BoolLiteral, tok.span)
        node.u.bool_literal = (tok.type == TokenType::True)

    } else if .token_is(TokenType::Minus) {
        let op = .consume(TokenType::Minus)
        let expr = .parse_factor(in_parens)
        node = AST::new_unop(ASTType::UnaryMinus, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Not) {
        let op = .consume(TokenType::Not)
        let expr = .parse_factor(in_parens)
        node = AST::new_unop(ASTType::Not, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Ampersand) {
        let op = .consume(TokenType::Ampersand)
        let expr = .parse_factor(in_parens)
        node = AST::new_unop(ASTType::Address, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Star) {
        let op = .consume(TokenType::Star)
        let expr = .parse_factor(in_parens)
        node = AST::new_unop(ASTType::Dereference, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Identifier) {
        let op = .consume(TokenType::Identifier)
        node = AST::new(ASTType::Identifier, op.span)
        node.u.ident.name = op.text

    } else if .token_is(TokenType::OpenParen) {
        let open = .consume(TokenType::OpenParen)
        node = .parse_expression(true)
        let close = .consume(TokenType::CloseParen)
        node.span = open.span.join(close.span)

    } else if .token_is(TokenType::SizeOf) {
        let start = .consume(TokenType::SizeOf)
        .consume(TokenType::OpenParen)
        let type = .parse_type()
        let close = .consume(TokenType::CloseParen)
        node = AST::new(ASTType::SizeOf, start.span.join(close.span))
        node.u.size_of_type = type

    } else {
        .unhandled_type("parse_expression")
    }

    let running = true
    while running {
        if not in_parens and .token().seen_newline {
            running = false
        } else if .token_is(TokenType::OpenParen) {
            let paren_span = .consume(TokenType::OpenParen).span
            let args = Vector::new()
            while not .token_is(TokenType::CloseParen) {
                let expr = .parse_expression(false)
                args.push(expr as untyped_ptr)
                if not .token_is(TokenType::CloseParen) {
                    .consume(TokenType::Comma)
                }
            }
            .consume(TokenType::CloseParen)
            let call_type = ASTType::Call
            let call = AST::new(call_type, paren_span)
            call.u.call.callee = node
            call.u.call.args = args
            call.u.call.added_method_arg = false
            node = call
        } else {
            running = false
        }
    }

    return node
}

def Parser::parse_term(&this, in_parens: bool): &AST {
    let lhs = .parse_factor(in_parens);
    let running = true
    while running and .token_is(TokenType::Star) or .token_is(TokenType::Slash) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_factor(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_additive(&this, in_parens: bool): &AST {
    let lhs = .parse_term(in_parens);
    let running = true
    while running and .token_is(TokenType::Plus) or .token_is(TokenType::Minus) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_term(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_bw_and(&this, in_parens: bool): &AST {
    let lhs = .parse_additive(in_parens);
    let running = true
    while running and .token_is(TokenType::Ampersand) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_additive(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_bw_or(&this, in_parens: bool): &AST {
    let lhs = .parse_bw_and(in_parens);
    let running = true
    while running and .token_is(TokenType::Line) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_bw_and(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_relational(&this, in_parens: bool): &AST {
    let lhs = .parse_bw_or(in_parens);
    let running = true
    while running and .token_is(TokenType::LessThan) or .token_is(TokenType::GreaterThan) or
            .token_is(TokenType::LessThanEquals) or
            .token_is(TokenType::GreaterThanEquals) or
            .token_is(TokenType::EqualEquals) or .token_is(TokenType::NotEquals) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_bw_or(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_logical_and(&this, in_parens: bool): &AST {
    let lhs = .parse_relational(in_parens);
    let running = true
    while running and .token_is(TokenType::And) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_relational(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_logical_or(&this, in_parens: bool): &AST {
    let lhs = .parse_logical_and(in_parens);
    let running = true
    while running and .token_is(TokenType::Or) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_logical_and(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }
    return lhs;
}

def Parser::parse_expression(&this, in_parens: bool): &AST {
    let lhs = .parse_logical_or(in_parens);
    let running = true

    while running and .token_is(TokenType::Equals) or .token_is(TokenType::PlusEquals) or
            .token_is(TokenType::MinusEquals) or .token_is(TokenType::StarEquals) or
            .token_is(TokenType::SlashEquals) {
        if (not in_parens and .token().seen_newline) { running = false; }
        let op = ASTType::from_token(.token().type)
        .curr += 1
        let rhs = .parse_logical_or(in_parens);
        lhs = AST::new_binop(op, lhs, rhs);
    }

    return lhs;
}


def Parser::parse_statement(&this): &AST {
    let node = 0 as &AST
    let start_span = .token().span

    if .token_is(TokenType::Return) {
        .consume(TokenType::Return)
        let expr = .parse_expression(false)
        node = AST::new_unop(ASTType::Return, start_span.join(expr.span), expr)

    } else if .token_is(TokenType::Defer) {
        .consume(TokenType::Defer)
        let expr = .parse_expression(false)
        node = AST::new_unop(ASTType::Defer, start_span.join(expr.span), expr)

    } else if .token_is(TokenType::If) {
        .consume(TokenType::If)
        let cond = .parse_expression(false)
        let then = .parse_block()

        let end_span = then.span
        let els = 0 as &AST
        if .consume_if(TokenType::Else) {
            els = .parse_block()
            end_span = els.span
        }
        node = AST::new(ASTType::If, start_span.join(end_span))
        node.u.if_stmt.cond = cond
        node.u.if_stmt.then = then
        node.u.if_stmt.els = els

    } else if .token_is(TokenType::While) {
        .consume(TokenType::While)
        let cond = .parse_expression(false)
        let body = .parse_statement()
        node = AST::new(ASTType::While, start_span.join(body.span))
        node.u.loop.cond = cond
        node.u.loop.body = body

    } else if .token_is(TokenType::For) {
        .unhandled_type("parse_statement")

    } else if .token_is(TokenType::Let) {
        .consume(TokenType::Let)
        let name = .consume(TokenType::Identifier)
        let end_span = name.span

        let type = 0 as &Type
        if .consume_if(TokenType::Colon) {
            type = .parse_type()
            end_span = type.span
        }
        let init = 0 as &AST
        if .consume_if(TokenType::Equals) {
            init = .parse_expression(false)
            end_span = init.span
        }
        .consume_newline_or(TokenType::Semicolon);

        node = AST::new(ASTType::VarDeclaration, start_span.join(end_span))
        node.u.var_decl.var = Variable::new(name.text, type, name.span)
        node.u.var_decl.init = init

    } else if .token_is(TokenType::OpenCurly) {
        node = .parse_block()

    } else {
        node = .parse_expression(false)
        .consume_newline_or(TokenType::Semicolon)
    }

    return node
}

def Parser::parse_block(&this): &AST {
    let node = AST::new(ASTType::Block, .token().span)
    .consume(TokenType::OpenCurly)

    let statements = Vector::new()
    while not .token_is(TokenType::CloseCurly) {
        let statement = .parse_statement()
        statements.push(statement as untyped_ptr)
    }
    node.u.block.statements = statements

    .consume(TokenType::CloseCurly)
    return node;
}

def Parser::parse_function(&this): &Function {
    .consume(TokenType::Def)

    let struct_name = 0 as string
    let is_method = false
    let is_static = false
    let name = .consume(TokenType::Identifier)
    if .consume_if(TokenType::ColonColon) {
        is_method = true
        struct_name = name.text
        name = .consume(TokenType::Identifier)
    }

    let func = Function::new(name.span)
    func.name = name.text
    func.is_method = is_method
    func.method_struct_name = struct_name

    .consume(TokenType::OpenParen)
    while not .token_is(TokenType::CloseParen) {
        let var_name = .consume(TokenType::Identifier)
        .consume(TokenType::Colon)
        let var_type = .parse_type()
        let var = Variable::new(var_name.text, var_type, var_name.span)
        func.params.push(var as untyped_ptr)
    }
    .consume(TokenType::CloseParen)

    if .consume_if(TokenType::Colon) {
        func.return_type = .parse_type()
    } else {
        func.return_type = Type::new(BaseType::Void, name.span)
    }

    func.is_extern = false
    func.body = .parse_block()
    return func
}

def Parser::parse_program(&this): &Program {
    let program = Program::new()
    while not .token_is(TokenType::EOF) {
        if .token_is(TokenType::Def) {
            let func = .parse_function()
            program.functions.push(func as untyped_ptr)
        } else {
            .unhandled_type("parse_program")
        }
    }
    return program
}
